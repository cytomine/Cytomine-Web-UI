<!-- Copyright (c) 2009-2021. Authors: see NOTICE file.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.-->

<template>
  <div class="storage-wrapper content-wrapper">
    <nav class="breadcrumb" aria-label="breadcrumbs">
      <ul>
        <li><router-link :to="`/storages`">{{$t('storages')}}</router-link></li>
        <li class="is-active"><a href="#" aria-current="page">{{selectedStorage.name}}</a></li>
      </ul>
    </nav>
    <div class="panel">
      <p class="panel-heading">
        {{ $t('upload') }}
      </p>
      <div class="panel-block" v-if="newUploadError || !userCanWriteInStorage">
        <b-message type="is-info" has-icon icon-size="is-small" v-if="newUploadError">
             {{ $t('error-cannot-upload') }}
        </b-message>
        <b-message type="is-info" has-icon icon-size="is-small" v-if="!userCanWriteInStorage">
          {{ $t('info-cannot-upload-if-admin-not-in-storage') }}
        </b-message>
      </div>
      <div class="panel-block" v-else>
        <b-message type="is-info" has-icon icon-size="is-small">
          <h2>{{$t('important-notes')}}</h2>
          <ul class="small-text">
            <li>{{$t('allowed-formats-upload-info')}}</li>
            <li>{{$t('vms-mrxs-upload-info')}}</li>
            <li>{{$t('zip-upload-info')}}</li>
            <li>{{$t('drag-drop-upload-info', {labelButton: $t('add-files')})}}</li>
            <li>{{$t('link-to-project-upload-info')}}</li>
          </ul>
        </b-message>

        <div class="columns">
          <div class="column is-one-quarter has-text-right">
            <strong>{{$t('storage')}}</strong>
          </div>
          <div class="column is-half">
            {{selectedStorage.name}}
          </div>
        </div>

        <div class="columns">
          <div class="column is-one-quarter has-text-right">
            <strong>{{$t('link-with-project')}}</strong>
          </div>
          <div class="column is-half">
            <cytomine-multiselect
              v-model="selectedProjects"
              :options="projects"
              label="name"
              track-by="id"
              :multiple="true"
              :close-on-select="true"
            />
          </div>
        </div>

        <div class="columns">
          <div class="column is-one-quarter has-text-right">
            <strong>{{$t('files')}}</strong>
          </div>
          <div class="column is-half">
            <table v-if="dropFiles.length > 0" class="table is-fullwidth upload-table">
              <tbody>
              <tr v-for="(wrapper, idx) in dropFiles" :key="idx">
                <td>{{wrapper.file.name}}</td>
                <td>{{filesize(wrapper.file.size)}}</td>
                <template v-if="wrapper.uploadedFile === null">
                  <td>
                    <progress class="progress is-info" :value="wrapper.progress" max="100">
                      {{wrapper.progress}}%
                    </progress>
                  </td>
                  <td>
                    <div class="field is-grouped">
                      <p class="control">
                        <button class="button is-link" @click="startUpload(wrapper)">
                          {{$t('button-start')}}
                        </button>
                      </p>
                      <p class="control">
                        <button class="button" @click="cancelUpload(idx)">
                          {{$t('button-cancel')}}
                        </button>
                      </p>
                    </div>
                  </td>
                </template>
                <template v-else>
                  <td>
                    <uploaded-file-status v-if="wrapper.uploadedFile" :file="wrapper.uploadedFile" />
                    <span v-else class="tag is-danger">
                      {{$t('upload-error')}}
                    </span>
                  </td>
                  <td>
                    <p class="control">
                      <button class="button" @click="cancelUpload(idx)">{{$t('button-hide')}}</button>
                    </p>
                  </td>
                </template>
              </tr>
              </tbody>
            </table>
            <em v-else class="first-child-like has-text-grey">{{$t('no-file')}}</em>
          </div>
        </div>

        <div class="columns">
          <div class="column is-half flex-column is-offset-one-quarter">
            <progress v-if="ongoingUpload" class="progress is-success" :value="overallProgress" max="100">
              {{overallProgress}}%
            </progress>

            <div class="buttons">
              <b-upload :value="plainFiles" type="is-link" multiple drag-drop @input="filesChange">
                <a class="button is-success">{{$t('add-files')}}</a>
              </b-upload>
              <button class="button is-link" @click="startAll()" :disabled="!filesPendingUpload">
                {{$t('start-upload')}}
              </button>
              <button class="button" @click="cancelAll()" :disabled="!filesPendingUpload && !ongoingUpload">
                {{$t('cancel-upload')}}
              </button>
              <button class="button" @click="hideFinished()" v-if="filesFinishedUpload">
                {{$t('hide-successful-upload')}}
              </button>
            </div>
          </div>
        </div>

      </div>
    </div>

  <list-uploaded-files :tableRefreshInterval="tableRefreshInterval"></list-uploaded-files>
  </div>
</template>

<script>
import {get} from '@/utils/store-helpers';

import {Cytomine, ProjectCollection, UploadedFile, UploadedFileStatus} from 'cytomine-client';
import axios from 'axios';
import filesize from 'filesize';
import _ from 'lodash';
import constants from '@/utils/constants.js';

import UploadedFileStatusComponent from './UploadedFileStatus';
import CytomineMultiselect from '@/components/form/CytomineMultiselect';
import CytomineTable from '@/components/utils/CytomineTable';
import ListUploadedFiles from './ListUploadedFiles';
export default {
  name: 'storage-upload',
  components: {
    CytomineMultiselect,
    'uploaded-file-status': UploadedFileStatusComponent,
    ListUploadedFiles,
    CytomineTable
  },
  data() {
    return {
      loading: true,
      newUploadError: false,
      timeoutRefreshSessionUploads: null,
      tableRefreshInterval: constants.STORAGE_REFRESH_INTERVAL,
      projects: [],
      selectedProjects: [],

      dropFiles: [],

      signature: '',
      signatureDate: '',

      revision: 0
    };
  },
  computed: {
    currentUser: get('currentUser/user'),
    selectedStorage: get('currentStorage/storage'),
    selectedStorageUsers: get('currentStorage/users'),
    userCanWriteInStorage() {
      return this.selectedStorageUsers===undefined ? false : this.selectedStorageUsers.findIndex(u => u.id === this.currentUser.id && (u.role === 'ADMINISTRATION' || u.role === 'WRITE'))!==-1;
    },
    finishedStatus() {
      return [
        UploadedFileStatus.CONVERTED,
        UploadedFileStatus.DEPLOYED
      ];
    },
    ongoingUpload() {
      return this.dropFiles.some(wrapper => wrapper.uploading);
    },
    filesPendingUpload() {
      return this.dropFiles.some(wrapper => !wrapper.uploading && wrapper.uploadedFile === null);
    },
    filesFinishedUpload() {
      return this.dropFiles.some(wrapper => !wrapper.uploading && wrapper.uploadedFile !== null
        && this.finishedStatus.includes(wrapper.uploadedFile.status));
    },
    overallProgress() {
      let nbUploads = 0;
      let totalProgress = 0;
      this.dropFiles.forEach(wrapper => {
        if(wrapper.uploading) {
          nbUploads++;
          totalProgress += wrapper.progress;
        }
      });
      return Math.floor(totalProgress / nbUploads);
    },
    uri() {
      return '/upload';
    },
    queryString() {
      let str = `cytomine=${constants.CYTOMINE_CORE_HOST}`;
      if(this.selectedStorage) {
        str += `&idStorage=${this.selectedStorage.id}`;
      }
      if(this.selectedProjects) {
        str += `&idProject=${this.selectedProjects.map(project => project.id).join(',')}`;
      }
      return str;
    },
    plainFiles() {
      return this.dropFiles.map(wrapper => wrapper.file);
    },
  },
  watch: {
    async queryString() {
      this.generateSignature();
    }
  },
  methods: {
    async generateSignature() {
      this.signatureDate = new Date().toISOString();
      console.log('watch.queryString');
      try {
        this.signature = await Cytomine.instance.fetchSignature({
          uri: this.uri,
          queryString: this.queryString,
          method: 'POST',
          date: this.signatureDate
        });
      }
      catch(error) {
        this.newUploadError = true;
      }
    },
    async fetchProjects() {
      console.log('fetchProjects');
      try {
        this.projects = (await ProjectCollection.fetchAll()).array;
      }
      catch(error) {
        console.log(error); // not mandatory for upload => only log error, no other action
      }
    },

    async refreshStatusSessionUploads() {
      let pendingStatus = [
        UploadedFileStatus.UPLOADED,
        UploadedFileStatus.DETECTING_FORMAT,
        UploadedFileStatus.EXTRACTING_DATA,
        UploadedFileStatus.CONVERTING,
        UploadedFileStatus.DEPLOYING,
      ];

      let unfinishedConversions = false;
      let statusChange = false;

      try {
        await Promise.all(this.dropFiles.map(async wrapper => {
          if(wrapper.uploadedFile) {
            let oldStatus = wrapper.uploadedFile.status;
            if(!pendingStatus.includes(oldStatus)) {
              return;
            }

            await wrapper.uploadedFile.fetch();
            let status = wrapper.uploadedFile.status;
            if(status !== oldStatus) {
              statusChange = true;
            }
            if(pendingStatus.includes(status)) {
              unfinishedConversions = true;
            }
          }
        }));
      }
      catch(error) {
        console.log(error);
        return;
      }

      if(statusChange) {
        this.revision++;
      }

      if(unfinishedConversions) {
        clearTimeout(this.timeoutRefreshSessionUploads);
        this.timeoutRefreshSessionUploads = setTimeout(this.refreshStatusSessionUploads, constants.ONGOING_UPLOAD_REFRESH_INTERVAL);
      }
    },

    filesChange(files) {
      files.forEach(file => {
        if(!file.processed) {
          file.processed = true;
          this.dropFiles.push({
            file,
            uploading: false,
            progress: 0,
            uploadedFile: null, // null if upload not finished, false if upload failed, UploadedFile instance if upload successful
            cancelToken: null
          });
        }
      });
    },
    filesize(size) {
      return (size) ? filesize(size, {base: 10}) : null;
    },

    startUpload(fileWrapper) {
      if(fileWrapper.uploading || fileWrapper.uploadedFile !== null) {
        return;
      }

      let formData = new FormData();
      formData.append('files[]', fileWrapper.file);
      fileWrapper.cancelToken = axios.CancelToken.source();
      fileWrapper.uploading = true;
      axios.post(
        constants.CYTOMINE_UPLOAD_HOST + this.uri + '?' + this.queryString,
        formData,
        {
          headers: {
            'authorization': `CYTOMINE ${this.currentUser.publicKey}:${this.signature}`,
            'dateFull': this.signatureDate, // will replace actual date value, so that signature is valid
            'content-type-full': 'null' // will erase actual content-type value, so that signature is valid
          },
          onUploadProgress: progress => {
            fileWrapper.progress = Math.floor((progress.loaded * 100) / progress.total);
          },
          cancelToken: fileWrapper.cancelToken.token
        }
      ).then(response => {
        fileWrapper.uploadedFile = new UploadedFile(response.data[0].uploadedFile);
        this.refreshStatusSessionUploads();
        this.revision++;
      }).catch(error => {
        if(!axios.isCancel(error)) {
          console.log(error);
          fileWrapper.uploadedFile = false;
        }
      }).finally(() => fileWrapper.uploading = false);
    },
    startAll() {
      this.dropFiles.forEach(wrapper => this.startUpload(wrapper));
    },

    cancelUpload(index) {
      let fileWrapper = this.dropFiles[index];
      if(fileWrapper.cancelToken) {
        fileWrapper.cancelToken.cancel();
      }
      this.dropFiles.splice(index, 1);
    },
    cancelAll() {
      let nbFiles = this.dropFiles.length;
      let idx = 0;
      for(let i = 0; i < nbFiles; i++) {
        if(this.dropFiles[idx].uploadedFile !== null) {
          idx++;
        }
        else {
          this.cancelUpload(idx);
        }
      }
    },
    updatedTree() {
      this.revision++; // updating the table will result in new files objects => the uf details will also be updated
    },
    debounceSearchString: _.debounce(async function(value) {
      this.searchString = value;
    }, 500),
    hideFinished() {
      let nbFiles = this.dropFiles.length;
      let idx = 0;
      for(let i = 0; i < nbFiles; i++) {
        let uploadedFile = this.dropFiles[idx].uploadedFile;
        if (uploadedFile !== null && this.finishedStatus.includes(uploadedFile.status)) {
          this.cancelUpload(idx);
        }
        else {
          idx++;
        }
      }
    }
  },
  // async activated() {
  //   console.log('activated', this.userNotAdminInStorage);
  //   this.userNotAdminInStorage = this.selectedStorage.users.findIndex(u => u.id === this.currentUser.id && (u.role === 'ADMINISTRATION' || u.role === 'WRITE'))===-1;
  // },
  created() {
    console.log('created');
    this.fetchProjects();
    this.refreshStatusSessionUploads();
    this.generateSignature();
    this.tableRefreshInterval = constants.STORAGE_REFRESH_INTERVAL;
    //this.userNotAdminInStorage = this.selectedStorage.users.findIndex(u => u.id === this.currentUser.id && (u.role === 'ADMINISTRATION' || u.role === 'WRITE'))===-1;
  },
  async destroyed() {
    console.log('deactivated');
    clearTimeout(this.timeoutRefreshSessionUploads);
    this.tableRefreshInterval = 0;
  }
};
</script>

<style scoped>
.small-text {
  font-size: 0.9em;
}

.upload-table  {
  position: relative;
  bottom: 0.4em;
}

.upload-table td {
  vertical-align: middle !important;
}

.upload-table td:first-child {
  width: 20vw;
}

.upload-table td:nth-child(2) {
  width: 10em;
}

.upload-table td:nth-child(3) {
  width: 15vw;
}

.upload-table td:last-child .field {
  justify-content: flex-end;
}

.upload-table td:last-child .control {
  text-align: right;
}

.column.flex-column {
  flex-direction: column;
}

.progress:not(:last-child) {
  margin-bottom: 0.75em;
}

.column:first-child {
  padding-top: 1.25em;
}

.first-child-like {
  display: block;
  padding-top: 0.5em;
}

.image-overview {
  max-height: 4em;
  max-width: 6em;
}

.panel-block.storage {
  min-height: 20vh;
  position: relative;
}
</style>

<style>
.storage-wrapper .upload-draggable .button {
  margin-bottom: 0;
}

.storage-wrapper .upload-draggable {
  margin-right: 0.75em;
  position: relative;
  bottom: 4px;
}

.search-uploaded-file {
  max-width: 25em;
}
</style>
